Pass one:

To implement pass one, I utilized the sample code you provided in p1example. I maintained headers.h, instructions.c, directives.c, symbols.c, and main.c. The file headers.h
contains structs for a symbol table and an opcode table, a symbols pointer array to hold the symbol instances, a opcodes pointer array to hold the opcode instances, as well
as function declarations for the program. The file headers.h is included in all other files so they have access to its structures and functions. The file main.c is the driver
file of the program. The main.c file takes in a SIC assembly file as a command line argument, reads it line by line, tokenizes each line, adjusts the location counter 
appropriately, and outputs a symbol table of each label and its memory address. To run my code in COP3404_P1, type 'make', and then type ./project1 followed by a SIC Assembly
file.

The file main.c starts by tokenizing each line into three tokens, token1, token2, and token3. If there are 3 tokens present, and token1 contains a valid symbol, my program
inserts the symbol into the symbol table and calls either 'ApplyDirective' or 'ApplyInstruction' to adjust the LocationCounter. If there are only two tokens present, my program
calls either 'ApplyDirective' or ApplyInstruction' to adjust the LocationCounter. If there is only one token present, my program calls 'ApplyInstruction' to adjust the
LocationCounter. After each line of the file has been read, my program outputs a symbol table of each label and its memory address. If any error is encountered throughout my
program, the following output is printed to the console:

ASSEMBLY ERROR:

<The contents of the source line of assembly which contains the error><CrLf>

Line <line #> <Description of Error Encountered><CrLf>

My program passes all test cases described by grade.


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
Pass two:

To implement pass two, I built upon the overall design of my code architecture for pass one, relying on the SymbolTable and OpcodeTable arrays. To store the original .sic
file so that another pass could be made, I created an array of assemblyLine structure pointers called AssemblyProgram. I populated this array during pass one. In order to format
and store the data for the object file, I decided to create several other structures, including an array of objectFileLine structure pointers called ObjectFile, and an array
of modicationRecordLine structure pointers called modicationRecord. To populate the object file, I decided to create a new .c module called fileHandler.c that ecapsulates 
methods associated with formatting and writing to the object file. Among these methods are makeHeader, makeTextRecord, makeModicationRecord, and makeEndRecord. I also have a 
method in fileHandler.c called buildObjectFile which took character array as a parameter and stored it in the ObjectFile. Writing these methods, largely due to working with 
so many pointers, was cumbersome; however, once they came together they made the process of building the object file easy. My pass two implementation passes all test cases 
that I can tell.


  
